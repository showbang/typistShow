{"meta":{"title":"Show's blog","subtitle":"Show's blog using hexo","description":"my first hexo blog","author":"keunhan Lee","url":"https://showbang.github.io/typistShow"},"pages":[],"posts":[{"title":"linuxapache","slug":"linuxapache","date":"2017-03-06T02:21:14.000Z","updated":"2017-03-06T04:50:31.633Z","comments":true,"path":"2017/03/06/linuxapache/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/03/06/linuxapache/","excerpt":"","text":"CentOS에서 apache 설치 및 was 연동이번포스팅은 WAS설치에 이어서 웹서버 설치 및 연동에 대해 포스팅 해보겠습니다. 설치준비물 필수패키지 설치앞에서 포스팅한 Tomcat설치를 따라하셨다면 건너가도 무방합니다. 12345yum -y install pcre-devel lua-devel libxml2-devel ncurses-devel zlib zlib-devel curl openssl openssl-devel libtermcap-devel libc-client-develbison gcc g++ cpp gcc-c++ freetype freetype-devel freetype-utils gd gd-devel libjpeg libjpeg-devel libpng libpng-devel curl curl-devel flex php-mbstring libexif-devel cmake 설치파일 다운로드 PCRE 라이브러리 (HTTPD 설치 필수 라이브러리) http://sourceforge.net/projects/pcre/files/pcre/pcre-x.xx.tar.gz (원하는 버전 다운로드) APR 라이브러리 (HTTPD 설치 필수 라이브러리) http://mirror.apache-kr.org/apr/apr-x.x.x.tar.gz (원하는 버전 다운로드)apr-util-x.x.x.tar.gz (원하는 버전 다운로드) GEOIP 라이브러리 (세계 IP 국가코드 라이브러리) https://github.com/maxmind/geoip-api-c/releasesGeoIP-x.x.x.tar.gz (원하는 버전 다운로드) https://github.com/maxmind/geoip-api-mod_geoip2/releasesgeoip-api-mod_geoip2-x.x.x.tar.gz (원하는 버전 다운로드) http://geolite.maxmind.com/download/geoip/database/GeoLiteCountry/GeoIP.dat.gzGeoIP.dat HTTPD 엔진 http://httpd.apache.org/httpd-x.x.xx.tar.gz (원하는 버전 다운로드) mod_jk.so (HTTPD와 WAS Connector) http://tomcat.apache.org/download-connectors.cgitomcat-connectors-x.x.xx-src.tar.gz Tomcat (미설치자만) http://tomcat.apache.org/download-70.cgiapache-tomcat-x.x.xx.tar.gz (원하는 버전 다운로드) 설치 설치 경로 설정 123export SETUP_HOME=/프로젝트이름/setupexport ENGINE_HOME=/프로젝트이름/project/engineexport HTTPD_HOME=$ENGINE_HOME/httpd export로 변수설정 후 폴더생성 123mkdir -p $ENGINE_HOMEmkdir -p $SETUP_HOMEmkdir -p $HTTPD_HOME httpd설치전 라이브러리를 먼저 설치해줍니다. cronolog (미설치 시)12345cd $SETUP_HOMEtar -zxvf cronolog-x.x.x.tar.gzcd cronolog-x.x.x./configuremake &amp;&amp; make install 여기서 jdk와 tomcat과는 다르게 ./configure와 make &amp;&amp; make install이 있는데./configure는 MakeFile 즉 컴파일 옵션이 설정되는 파일이 만들어지는 명령어입니다.컴파일하는 클라이언트의 사양에 맞는 환경에 알맞는 파일이 생성됩니다.그 후 make로 소스코드를 실제로 컴파일하여 binary 파일을 생성시킨 후make install 명령어로 만들어진 binary 파일을 ./configure에서 지정한 ENGINE_HOME으로이동시켜줍니다. 이 이후에도 ./configure와 make &amp;&amp; make install이 있는데 마찬가지입니다. apr 설치 12345cd $SETUP_HOMEtar -zvxf apr-x.x.x.tar.gzcd apr-x.x.x./configure --prefix=$ENGINE_HOME/apr-x.x.xmake &amp;&amp; make install pcre 설치 12345cd $SETUP_HOMEtar -zvxf pcre-x.xx.tar.gzcd pcre-x.xx./configure --prefix=$ENGINE_HOME/pcre-x.xxmake &amp;&amp; make install 그 후 httpd를 설치 해줍니다. httpd 설치12345678910111213141516cd $SETUP_HOMEtar -zxvf httpd-2.4.10.tar.gzcd httpd-2.4.10export CFLAGS=\"$&#123;CFLAGS&#125; -DHARD_SERVER_LIMIT=8192 -DDEFAULT_SERVER_LIMIT=8192\"./configure --prefix=$ENGINE_HOME/httpd \\--with-apr=$ENGINE_HOME/apr-x.x.x \\--with-apr-util=$ENGINE_HOME/apr-util-x.x.x \\--with-pcre=$ENGINE_HOME/pcre-x.xx \\--with-mpm=prefork \\--enable-cache \\--enable-ssl --with-ssl=/usr \\--enable-rewrite --enable-lib64 --libdir=/usr/lib64 \\--enable-mods-shared=all --enable-so --enable-rewritemake &amp;&amp; make install CFLAGS명령어로 먼저 설치 한 라이브러리들과 연동 후 binary 파일을 생성시킵니다. geoIP 설치1234567891011121314 cd $SETUP_HOMEtar -zvxf GeoIP-x.x.x.tar.gzcd ./GeoIP-x.x.x./configure --prefix=$ENGINE_HOME/GeoIPmake &amp;&amp; make installcd $SETUP_HOMEtar -zvxf geoip-api-mod_geoip2-1.2.9.tar.gzcd ./geoip-api-mod_geoip2-1.2.9$HTTPD_HOME/bin/apxs -i -a \\-L$ENGINE_HOME/GeoIP/lib \\-I$ENGINE_HOME/GeoIP/include \\-lGeoIP -c ./mod_geoip.c geoIP 라이브러리를 생성하게되면 $HTTPD_HOME/modules/ 위치에 mod_geoip.so 가 생성됩니다. 그리고 $HTTPD_HOME/conf 위치에 httpd.conf파일에 LoadModule geoIP가 추가됩니다. 그 후 GeoIP.dat 파일의 압축해제 후 GeoIP 폴더에 복사합니다. 1234cd $SETUP_HOMEgzip -d GeoIP.dat.gzmkdir -p $ENGINE_HOME/GeoIP/share/GeoIPcp ./GeoIP.dat $ENGINE_HOME/GeoIP/share/GeoIP/. tomcat-connector 설치123456cd $SETUP_HOMEtar -zxvf tomcat-connectors-x.x.xx-src.tar.gzcd tomcat-connectors-x.x.xx-src/native/./buildconf.sh./configure --with-apxs=$HTTPD_HOME/bin/apxsmake &amp;&amp; make install 이 작업이 완료되면 $HTTPD_HOME/modules 안에 mod_jk.so 파일이 생성됩니다. 이렇게 설치작업은 완료됩니다. 설치를 완료 한 후, ENGINE_HOME은 WAS 연동세팅Apache웹서버와 Tomcat의 연동을 위하여 HTTPD의 옵션을 설정해줍니다. 1cd $HTTPD_HOME/conf 로 이동해보면 이렇게 위치가 되어있습니다.workers.properties파일과 mod_jk.conf 파일같은경우 처음세팅하신 분들은 없을 수도 있습니다.그럴경우에는 파일을 추가해주시면 됩니다. httpd.conf먼저 httpd.conf 파일을 세팅합니다 1vi httpd.conf ServerRoot를 아파치가 설치된 경로로 변경합니다.Listen 포트를 80으로 선언해줍니다. ServerName을 해당서버의 IP로 변경합니다. LoadModule에 Mod_jk.so를 추가해줍니다. 그 후 mod_jk.conf파일을 Include 시킵니다.지금 당장 파일이 없어도 생성을 할 것이기 때문에 일단 Include 시켜줍니다. 일단 이 상태에서 httpd.conf 파일을 저장해줍니다. workers.propertiesworkers.properties 파일을 열어줍니다.1vi workers.properties 이렇게 vi 편집모드로 열게 되면 만약 파일이 있다면 파일을 연 후, 편집모드로 들어가고없는파일이라면 새 파일이 생성됩니다. 그 후 workers.properties 파일에 밑 내용을 추가합니다. workers.tomcat_home=톰캣경로worker.list=tomcatworker.tomcat.type=ajp13worker.tomcat.host=xxx.xxx.xxx.xxx-&gt; 연결될 와스 ip로 변경worker.tomcat.port=8009worker.tomcat.lbfactor=1worker.tomcat.connection_pool_timeout=600worker.tomcat.socket_keepalive=1 톰캣의 server.xml에 보면 ajp13타입의 8009포트가 열려있습니다. 이 포트를 통하여 Tomcat과 연동합니다. mod_jk.conf 이 위에서 httpd.conf 파일에 Include 시켰던 mod_jk.conf 파일을 편집합니다. 1vi mod_jk.conf 편집모드로 열어줍니다. 이때도, 파일이 없다면 파일은 생성됩니다. 밑의 코드를 추가시켜줍니다. 로그파일과 tomcat과의 연동 시 어떤 properties를 사용하는지어떤 파일을 tomcat에 넘기는지를 세팅해줍니다. JkWorkersFile /projectName/project/engine/httpd/conf/workers.propertiesJkShmFile /projectName/project/engine/apache-tomcat-8.0.41/logs/modjk%Y%m%d.shmJkLogFile /projectName/project/engine/apache-tomcat-8.0.41/logs/modjk%Y%m%d.logJkLogLevel errorJkMount / tomcatJkUnmount /.jsp tomcat 이렇게 세팅을 마친 후 웹 서버를 실행 시킵니다. $HTTPD_HOME/bin 으로 이동해보면 apachectl이라는 파일이 존재하는데 ./apachectl start : 웹서버기동 ./apachectl stop : 웹서버 중지 ./apachectl restart : 웹서버 재기동 이렇게 웹서버를 기동시킵니다. 웹서버를 기동 시킨 후 8080 포트가 아닌 80포트로 접속 시 tomcat 고양이 메인화면이 뜨면 성공입니다.","categories":[{"name":"etc","slug":"etc","permalink":"https://showbang.github.io/typistShow/categories/etc/"},{"name":"web","slug":"etc/web","permalink":"https://showbang.github.io/typistShow/categories/etc/web/"}],"tags":[]},{"title":"CentOS에서 tomcat 설치","slug":"linuxTomcat","date":"2017-03-04T01:47:58.000Z","updated":"2017-03-06T03:52:19.000Z","comments":true,"path":"2017/03/04/linuxTomcat/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/03/04/linuxTomcat/","excerpt":"","text":"CentOS에서 tomcat 설치이번포스팅은 centOS 리눅스환경에서 tomcat 설치방법을 포스팅해보겠습니다.추후 apache 웹서버와의 연동까지 포스팅할 예정입니다. 설치준비물 필수패키지 설치12345yum -y install pcre-devel lua-devel libxml2-devel ncurses-devel zlib zlib-devel curl openssl openssl-devel libtermcap-devel libc-client-develbison gcc g++ cpp gcc-c++ freetype freetype-devel freetype-utils gd gd-devel libjpeg libjpeg-devel libpng libpng-devel curl curl-devel flex php-mbstring libexif-devel cmake 위의 패키지를 OS에 설치해줍니다. 그 후, tomcat 설치에 필요한 파일들을 다운받습니다. jdk http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.htmljdk-7u79-linux-x64.tar (원하는 버젼의 tar파일) Cronlog Library 이 라이브러리는 로그를 날짜별로 파싱해주는 라이브러리입니다.http://cronolog.org/cronolog-1.6.2.tar.gz (원하는 버전의 tar파일) Tomcat http://tomcat.apache.org/download-70.cgiapache-tomcat-7.0.62.tar (원하는 버전의 tar파일) 설치 설치 경로 설정setup_home과 engine_home은 자주 사용하기 때문에 변수선언을 해줍니다. 12export SETUP_HOME = /프로젝트명/setupexport ENGINE_HOME = /프로젝트명/project/engine 그 다음 폴더를 생성해줍니다.12mkdir -p $ENGINE_HOMEmkdir -p $SETUP_HOME 폴더를 생성한 후, 다운받은 tar 압축파일들을 SETUP_HOME폴더에 위치시킵니다. jdk 설치123cd $SETUP_HOMEtar -vxf jdk_xxxx_linux-x64.tar.gz mv ./jdkxxxx.xx/ $ENGINE_HOME/. SETUP_HOME으로 이동 후 tar압축파일을 풀고 SETUP_HOME에 생성된 jdk 폴더를 ENGINE_HOME으로 이동 시킵니다. tomcat 설치 123cd $SETUP_HOMEtar -zvxf ./apache-tomcat-x.x.xx.tar.gzmv ./apache-tomcat-x.x.xx/ $ENGINE_HOME/. cronlog 설치 12345cd $SETUP_HOMEtar -zvxf cronolog-x.x.x.tar.gzcd cronolog-x.x.x./configure --prefix=$ENGINE_HOME/cronologmake &amp;&amp; make install 여기서 jdk와 tomcat과는 다르게 ./configure와 make &amp;&amp; make install이 있는데./configure는 MakeFile 즉 컴파일 옵션이 설정되는 파일이 만들어지는 명령어입니다.컴파일하는 클라이언트의 사양에 맞는 환경에 알맞는 파일이 생성됩니다.그 후 make로 소스코드를 실제로 컴파일하여 binary 파일을 생성시킨 후make install 명령어로 만들어진 binary 파일을 ./configure에서 지정한 ENGINE_HOME으로이동시켜줍니다. 이렇게 전부 설치를 하고 ENGINE_HOME으로 이동시켰다면 현재 ENGINE_HOME에 있어야할것은 이렇게 3개의 폴더가 위치하고 있어야 합니다. 옵션조정옵션조정은 설정방법과 의도에따라 옵션이 다르기 때문에 원하시는 설정으로 바꿔주시면 됩니다. 먼저 server.xml 파일을 편집모드로 열어봅니다.1vi /프로젝트이름/project/engine/apache-tomcat-x.x.xx/conf/server.xml 편집모드로 열고 밑으로 내리면 Host 설정과 Context 설정이 있습니다.Host appBase는 보통 webapps 폴더에 설정하게 되는데 war파일을 배포하여 tomcat을 실행시키면 webapps 폴더밑에 클래스파일이 생성되기 때문입니다.Context같은 경우는 기본 path를 설정해주시고 appBase 폴더 밑에 어떤 폴더를 실행할건지 설정해줍니다. WAS OS setting먼저 etc폴더에 있는 profile파일을 편집모드로 열어줍니다.1vi /etc/profile 그 후 밑의 변수설정파일들을 profile파일에 추가해줍니다. #. /etc/init.d/msm_profileexport LANG=ko_KR.eucKRexport ENGINE_HOME=/프로젝트명/project/engineexport JAVA_HOME=$ENGINE_HOME/jdkx.x.xx_xxexport CATALINA_HOME=$ENGINE_HOME/apache-tomcat-x.x.xxexport CLASSPATH=$CATALINA_HOME/lib:$CLASSPATH:$JAVA_HOME/lib:.export PATH=$PATH:$JAVA_HOME/bin:$CATALINA_HOME/binexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$CATALINA_HOME/lib WAS 기동일단 apache-tomcat의 bin폴더로 이동합니다.그 곳에있는 셸스크립트로 WAS를 기동합니다. ./startup.sh : 기동./shutdown.sh : 중지 ./startup.sh를 실행시킨 후, 8080포트로 접속했을 때 Apache-tomcat 고양이가 있는페이지가 뜨면 성공입니다. server.xml 설정과 세세한 설정파일들은 사용하는 사람들에따라 다르기 때문에, 자세히 다루지 않았습니다.저도 물론 초보이지만 혹시 제 블로그를 보고 따라하시다가 안되면 댓글달아주시면답변드리겠습니다~~다음 포스팅은 apache웹서버 설치 후 tomcat과 연동하는 방법에 대해 포스팅하겠습니다.","categories":[{"name":"etc","slug":"etc","permalink":"https://showbang.github.io/typistShow/categories/etc/"},{"name":"web","slug":"etc/web","permalink":"https://showbang.github.io/typistShow/categories/etc/web/"}],"tags":[]},{"title":"이벤트키코드","slug":"이벤트키코드","date":"2017-02-20T07:05:17.000Z","updated":"2017-02-20T07:13:08.530Z","comments":true,"path":"2017/02/20/이벤트키코드/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/02/20/이벤트키코드/","excerpt":"","text":"event.keyCode를 위한 번호표 BACKSPACE =&gt; 8 TAB =&gt; 9 ENTER =&gt; 13 SHIFT =&gt; 16 CTRL =&gt; 17 ALT =&gt; 18 PAUSEBREAK =&gt; 19 CAPSLOOK =&gt; 20 한/영 =&gt; 21 한자 =&gt; 25 ESC =&gt; 27 SPACEBAR =&gt; 32 PAGEUP =&gt; 33 PAGEDN =&gt; 34 END =&gt; 35 HOME =&gt;36 ← =&gt; 37 ↑ =&gt; 38 → =&gt; 39 ↓ =&gt; 40 0 =&gt; 48 1 =&gt; 49 2 =&gt; 50 3 =&gt; 51 4 =&gt; 52 5 =&gt; 53 6 =&gt; 54 7 =&gt; 55 8 =&gt; 56 9 =&gt; 57 INSERT =&gt; 45 DELETE =&gt; 46 A =&gt; 65 B =&gt; 66 C =&gt; 67 D =&gt; 68 E =&gt; 69 F =&gt; 70 G =&gt; 71 H =&gt; 72 I =&gt; 73 J =&gt; 74 K =&gt; 75 L =&gt; 76 M =&gt; 77 N =&gt; 78 O =&gt; 79 P =&gt; 80 Q =&gt; 81 R =&gt; 82 S =&gt; 83 T =&gt; 84 U =&gt; 85 V =&gt; 86 W =&gt; 87 X =&gt; 88 Y =&gt; 89 Z =&gt; 90 윈도우(LEFT) =&gt; 91 윈도우(RIGHT) =&gt; 92 기능키 =&gt; 93 0(NUMPAD) =&gt; 96 1(NUMPAD) =&gt; 97 2(NUMPAD) =&gt; 98 3(NUMPAD) =&gt; 99 4(NUMPAD) =&gt; 100 5(NUMPAD) =&gt; 101 6(NUMPAD) =&gt; 102 7(NUMPAD) =&gt; 103 8(NUMPAD) =&gt; 104 9(NUMPAD) =&gt; 105 .(NUMPAD) =&gt; 110 /(NUMPAD) =&gt; 111 *(NUMPAD) =&gt; 106 +(NUMPAD) =&gt; 107 -(NUMPAD) =&gt; 109 F1 =&gt; 112 F2 =&gt; 113 F3 =&gt; 114 F4 =&gt; 115 F5 =&gt; 116 F6 =&gt; 117 F7 =&gt; 118 F8 =&gt; 119 F9 =&gt; 120 F10 =&gt; 121 F11 =&gt; 122 F12 =&gt; 123 NUMLOCK =&gt; 144 SCROLLLOCK =&gt; 145 = =&gt; 187 ` =&gt; 192","categories":[{"name":"javascript","slug":"javascript","permalink":"https://showbang.github.io/typistShow/categories/javascript/"}],"tags":[]},{"title":"webServer와 WAS의 차이점","slug":"webServerWAS","date":"2017-02-07T01:59:02.000Z","updated":"2017-02-07T02:14:30.654Z","comments":true,"path":"2017/02/07/webServerWAS/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/02/07/webServerWAS/","excerpt":"","text":"WebServer와 WAS의 차이점Web ServerWeb browser client로부터 HTTP Request를 받아 자료콘텐츠에 따라 HTTP에 반응합니다.Client가 GET,POST,UPDATE,DELETE등의 메소드를 이용하여 Request를 요청하면,그에 해당하는 결과값을 돌려주는 기능을 합니다. Client가 요청한 것 중에 웹서버 자체적으로처리할 수 없는 것들을 Tomcat과 같은 컨테이너나 PHP모듈과 같이 처리가 가능한 곳으로 넘겨,처리결과를 받아 Client에게 전송해주는 역할도 수행합니다. WAS(Web Application Server)웹 기반 시스템 개발을 용이하게 해주며 안정적인 트랜젝션 처리를 해주는 미들웨어 시스템.Client와 SErver간 Application 연동을 해줍니다. 웹서버에 Container가 추가된 것이,WAS.Container는 JSP,SErvlet등의 구동 환경을 제공하여 동적 Data처리를 가능하게 만들어줍니다. 위의 그림을 보면 볼 수 있듯이 WAS에서는 Application Server에서의 코드와 데이터를조작할 수 있게 하여 동적인 데이터로 처리할 수 있게 만들어 주는 역할을 합니다.우리가 흔히 쓰는 Apache가 대표적인 WebServer이며, Tomcat은 Apache사에서 제공하는WAS입니다. WAS가 WebServer를 포함하고 있으므로 WebServer가 필요하지 않다고 생각할 수도 있는데,WebServer는 정적인 데이터를 처리하는 서버이기 때문에, 이미지나 단순 html 파일과 같은리소스를 제공하는 서버는 WAS에서 제공하는 Container 기능이 필요가 없으며 WebServer를이용하는 것이 더 빠르고 안정적입니다. 물론 DB에서 데이터를 주고 받거나, 프로그램상에서의데이터 조작이 이루어져야 할때에는 WAS를 사용해야 합니다. 이러한 장단점들을 보완하기 위하여 두개의 서버를 연동하여 사용할 수 있습니다.Client Request는 WebServer에서 받고 내부 프로그램은 WAS를 통하여 처리한다면,정적,동적인 데이터를 모두 효과적인 처리를 할 수 있게 됩니다. WebServer와 WAS를 연동하는 이유 WAS는 WebServer만큼 정적인 데이터를 빠르며 안정적이게 처리하지 못한다. WAS는 WebServer만큼 다양한 옵션 및 환경 설정 기능을 제공하지 않는다. 상용화 되어있는 많은 사이트들이 Webserver기반으로 많은 시스템을 개발해놓은 상태. CGI,PHP등 ServerSide Application등과 다양한 모듈들을 WAS에서는 실행시킬수 없다.","categories":[{"name":"etc","slug":"etc","permalink":"https://showbang.github.io/typistShow/categories/etc/"},{"name":"web","slug":"etc/web","permalink":"https://showbang.github.io/typistShow/categories/etc/web/"}],"tags":[]},{"title":"cache","slug":"cache","date":"2017-02-07T01:44:19.000Z","updated":"2017-02-07T01:56:56.309Z","comments":true,"path":"2017/02/07/cache/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/02/07/cache/","excerpt":"","text":"Cache와 Proxy Server란?Cache데이터의 값을 미리 복사해 놓는 임시 저장소를 뜻합니다.접근 시간에 비하여 기존의 데이터를 접근하닌 시간이 오래 걸릴 때,데이터의 양을 계산하는 시간을 절약하여 빠르게 접근 할 수 있습니다.Cache에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이더 빠른 속도로 데이터에 접근 할 수 있습니다. 예를 들어, 데이터의 변경이 없는 페이지에 돌아가거나, 이전페이지로 갈 때다시 DB에 접속하여 값을 받아오는 것이 아니라, Cache에 저장되어 있는값을 불러들여 사용하게 됩니다. 이렇게 되면 서버의 과부하문제도 생기지 않고이미 불러온 데이터를 가지고 있는 상태이기 때문에, 빠른처리가 가능해집니다.캐쉬는 default값으로 사용을 하게 설정 되어있는데, HTTP 응답헤더를 통해,웹 브라우저가 캐시를 사용할지 안할지의 여부를 설정 할 수 있습니다.Cache-Control은 HTTP1.1, Pragrama는 HTTP1.0 버전에서 지원하는헤더입니다. “no-cache”를 값으로 설정해주면 캐시를 사용하지 않게 됩니다. 12response.setHeader(\"Cache-Control\",\"no-cache\");response.setHeader(\"Pragma\",\"no-cache\"); Proxy Server클라이언트가 자신을 통하여 다른 네트워크 서비스에 간접적으로 접속할 수 있게도와주는 미들웨어 컴퓨터 또는 프로그램을 말합니다.서버와 클라이언트 사이의 중계자 역할을 하며 대리로 통신을 수행하는 기능을,proxy라고 하는데, 이 기능을 실행시키는 서버를 proxy Server라고 합니다. Proxy Server의 사용 목적은 앞서 말한 Cache를 사용하여 리소스의 접근을 빠르게 합니다. 네트워크 서비스나 콘텐츠로 접근 정책을 적용하기 위하여 사용합니다. 지역제한을 우회하기 위하여 사용할 수도 있습니다.","categories":[{"name":"etc","slug":"etc","permalink":"https://showbang.github.io/typistShow/categories/etc/"},{"name":"web","slug":"etc/web","permalink":"https://showbang.github.io/typistShow/categories/etc/web/"}],"tags":[]},{"title":"restful이란?","slug":"restful이란","date":"2017-02-07T01:24:12.000Z","updated":"2017-02-07T01:42:13.588Z","comments":true,"path":"2017/02/07/restful이란/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/02/07/restful이란/","excerpt":"","text":"resutful 이란??Rest는 Representation State Transfer의 줄임말로써, 표현 가능한 상태로 전송이라는 뜻.최근에는 다양화 된 디바이스로 인하여 Restful Server를 사용하는 빈도가 많아지고 있습니다.이렇게 되면서 하나의 클라이언트를 위한 서버를 구성하게 되면 비효율 적인 일처리가 되므로,하나의 서버로 다양한 클라이언트에게 대응할 수 있게 하는것이 바로 RestAPI입니다.기존의 웹 클라이언트와의 통신은 데이터와 html코드를 넘겨 화면구성까지 해줬다면, Restful은xml,json형식으로 데이터만 주고받아 다른 구조를 가지고 있는 디바이스에서 유지보수가 용이합니다.또, restful은 Controller에 매핑해놓은 메소드 이름을 url에 포함하여 접근하기 때문에,어떠한 액션을 수행하려고 하고 무슨 개체에 대해 작업을 하는지 직관적으로 보기 쉬워,오픈 API로써의 활용이 가능해집니다. Restful의 목표 구성요소끼리의 통신규모를 확장 시킬수 있습니다. 인터페이스를 범용적으로 사용할 수 있습니다. Data만을 송수신. 응답시간을 감소시킬 수 있습니다.RestAPI 구현의 제한 조건 클라이언트와 서버는 일관적인 인터페이스로 분리되어야 합니다. 각 요청간에 클라이언트의 context가 서버에 저장되면 안됩니다. 클라이언트는 리퀘스트를 캐싱할 수 있어야 합니다. 아키텍쳐를 단순화시켜 분리, 클라이언트와 서버가 독립적 개선되게 합니다. xml,son형식으로 통신을 하는데, 자바프로그래밍에서는 보통 jsonData를 주고 받습니다. Json이란?Javascript Object Notation의 약자이며, 객체 형식으로 자료를 표현해줍니다.Json은 데이터를 {key:value[,key:value]} 형식으로 표현하는 데이터 포맷이며,간단한 데이터를 xml보다 간편하게 표현하기 위하여 만들어졌습니다.xml처럼 부가기능이 없기 때문에 parsing도 빠르며 간단하기 때문에 클라이언트쪽이나모바일사이트에서 유용하게 사용되고 있습니다. 그러나 Json Data는 해당 자바스크립트가로드된 서버의 데이터가 한정되어 있습니다.구글,네이버같은 상용웹페이지에서의데이터를 해당 사이트에서 받아올 수 없습니다. 왜냐하면 Json은 단순 데이터 포맷이고,그 데이터를 불러오기 위해서는 XMLHttpRequest()함수를 사용해야 하는데, 이 함수는동일한 서버에 대한 것만 지원합니다. 이 문제를 어느정도 해결할 수 있는 Jsonp가 있습니다. Jsonp란?Json에서 말한 문제는 Same-Origin Policy정책으로 인해 야기됩니다.브라우저에서 다른 도메인으로 접속을 원천적으로 봉쇄하는 것인데, 만약 이런 정책이 없다면디도스 공격이나, 악성코드들로 그 도메인이 가득 채워 질 것입니다.하지만 요즘같이 복잡하게 엮여있는 웹 환경에서 다른 사이트간 데이터 교환은 필수상황입니다.이것을 해결하기 위하여 jsonp라는 개념이 생겼습니다.jsonp는 get방식만을 허용하기 때문에 데이터 크기가 제한되어 있는 단점이 있습니다.","categories":[{"name":"etc","slug":"etc","permalink":"https://showbang.github.io/typistShow/categories/etc/"},{"name":"web","slug":"etc/web","permalink":"https://showbang.github.io/typistShow/categories/etc/web/"}],"tags":[]},{"title":"1=1 조건을 넣는 이유","slug":"where1-1","date":"2017-02-07T01:10:00.000Z","updated":"2017-02-07T01:23:29.043Z","comments":true,"path":"2017/02/07/where1-1/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/02/07/where1-1/","excerpt":"","text":"myBatis 쿼리에서 1=1 조건을 넣는 이유myBatis 쿼리문을 볼때, 가끔씩 where 1=1 이라는 조건을 볼 수 있습니다. 1234567891011121314&lt;select id=\"getUserList\" resultMap=\"userSelectMap\"&gt; SELECT TAG_ID, CONT_ID, TAG_STR, TAG_USER FROM RESUME WHERE 1=1 &lt;if test=\"!tagId.equals(''.toString())\"&gt; AND TAG_ID LIKE '%' || #&#123;tagId:VARCHAR&#125; || '%' &lt;/if&gt; &lt;if test=\"!tagName.equals(''.toString())\"&gt; AND TAG_NAME LIKE '%' || #&#123;tagName:VARCHAR&#125; || '%' &lt;/if&gt;&lt;/select&gt; 이렇게 if문에 들어가기전에 1=1이라는 조건을 줍니다.만약 저 IF문에 아무것도 걸리지 않는다면, WHERE 키워드만 남게되어 에러가 나게 됩니다.이렇게 IF문에 걸리지 않아도 SQL문에서 EXCEPTION이 나지 않게 하기 위하여,1=1 조건을 줘서 EXCEPTION을 방지합니다.","categories":[{"name":"etc","slug":"etc","permalink":"https://showbang.github.io/typistShow/categories/etc/"},{"name":"myBatis","slug":"etc/myBatis","permalink":"https://showbang.github.io/typistShow/categories/etc/myBatis/"}],"tags":[]},{"title":"myBatis에서 insert 후 원하는 컬럼 select 해오기","slug":"myBatisKeyProperty","date":"2017-02-03T00:49:08.000Z","updated":"2017-02-07T01:23:35.384Z","comments":true,"path":"2017/02/03/myBatisKeyProperty/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/02/03/myBatisKeyProperty/","excerpt":"","text":"myBatis에서 insert 후 원하는 컬럼 select 해오기코딩을 하면서 insert후에 insert한 컬럼의 값을 가져올 일이 있습니다.이때 keyProperty를 이용하면 insert 후 return값으로 int값이 아닌원하는 컬럼의 값을 return받을 수 있습니다. 1234567891011121314151617181920&lt;insert id=\"insertBaby\" parameterType=\"baby\" useGeneratedKeys=\"true\" keyProperty=\"bNo\"&gt; INSERT INTO baby ( B_NAME ,B_BIRTH ,B_SEX ,B_NATURE ,B_TYPE ,B_PHOTO ,U_NO ) VALUES ( #&#123;bName&#125; ,#&#123;bBirth:VARCHAR&#125; ,#&#123;bSex&#125; ,#&#123;bNature:VARCHAR&#125; ,#&#123;bType:VARCHAR&#125; ,#&#123;bPhoto:VARCHAR&#125; ,#&#123;mom.uNo&#125; ) &lt;/insert&gt; 위 코드처럼 userGeneratedKeys의 값을 true로 지정해주고,keyProperty값에 return받을 column을 지정해줍니다.이렇게 되면 insert 후 myBatis에서 return해주는 값은insert한 bNo값을 return해줍니다. keyProperty를 이용하면insert 후 select해오는 로직을 생략할 수 있습니다.","categories":[{"name":"etc","slug":"etc","permalink":"https://showbang.github.io/typistShow/categories/etc/"},{"name":"myBatis","slug":"etc/myBatis","permalink":"https://showbang.github.io/typistShow/categories/etc/myBatis/"}],"tags":[]},{"title":"jqGrid상세사용법","slug":"jqGrid상세사용법","date":"2017-01-31T06:35:31.000Z","updated":"2017-01-31T10:37:48.591Z","comments":true,"path":"2017/01/31/jqGrid상세사용법/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/01/31/jqGrid상세사용법/","excerpt":"","text":"jqGrid 상세사용법.jqGrid의 기초적인 사용법에 이어서 상세사용법을 포스팅하도록 하겠습니다. 12345678910111213141516171819202122232425262728293031323334$(\"#id\").jqGrid(&#123; url : \"데이터를 받아올 url\", datatype : \"받아올 datatype\", colNames : ['셀의 이름1', '셀의 이름2'....], colModel : [ &#123; name : '받아올 변수의 이름', index : 'jqGird안에서 접근할 이름', width : cell의 너비, align : 'text의 정렬' =&gt; left,center,right &#125;, &#123; name : '받아올 변수의 이름1', index : 'jqGird안에서 접근할 이름1', width : cell의 너비, align : 'text의 정렬' =&gt; left,center,right &#125; . . . . ], loadtext : \"로딩중 표시할 텍스트\", caption : \"그리드의 제목\", postData : &#123; //데이터를 받아올 때 넘길 변수를 설정해줍니다. data1 : \"data1\"; data2 : \"data2\"; . . . . &#125;&#125;); 앞서 포스팅했던 기초적인 사용법입니다. jqGrid안의 keyword를 하나씩 설명해드리겠습니다.일단 request를 보낸 URL에서 다시 response를 받을때는 보통 json 형식으로 많이 보내기때문에 json형식 기준으로 포스팅을 하겠습니다.Controller에서 보낸 json 형식의 데이터의 키값을 임의로 “python”,”java”,”php” 이 세개로 하겠습니다. url앞서 말씀드린거와 같이 request를 보낼 url을 선언해줍니다. Java코딩 기준으로 RequestMapping으로 설정해놓은 value값이 되겠습니다. datatype이것도 역시 받아올 데이터타입을 선언해줍니다. json타입이면 ‘json’, xml파일이면 ‘xml’로 설정해줍니다.여기서 주의할점은 대소문자 구분입니다. 카멜케이스에 익숙해져 dataType으로 선언한다면 읽어들이지 못합니다. colNames colNames는 위 사진의 빨간부분을 설정해줍니다. 즉 테이블의 셀의 제목을 설정해줍니다.제가 임의로 키값을 설정한걸로 선언한다면1colNames : ['파이썬','자바','피에이치피'] 이렇게 선언이 됩니다.colNamse는 자신이 원하는 제목으로 설정해도 무방합니다. colModel데이터의 변수명을 설정해줍니다. Controller에서 list를 Json 형식으로 변환하여 들어오면 뿌려줄 변수명을 설정해주면 라이브러리에서 grid를 그려줍니다.지금 상황에서는1234567891011121314151617181920colModel : [ &#123; name : 'python', index : 'python', width : 100, align : 'left' &#125;, &#123; name : 'java', index : 'java', width : 100, align : 'center' &#125;, &#123; name : 'php', index : 'php', width : 50, align : 'right' &#125; ] 이런식으로 선언이 됩니다.-name : response받은 변수와 이름을 맞춥니다.-index : jqGrid에서 접근할 이름입니다. 미지정시 name을 따라갑니다-width : 셀의 너비를 선언합니다-align : 텍스트의 정렬조건입니다.-key : 유일한 rowId값을 위해 id를 지정할 수 있습니다. 반드시 하나의 컬럼에만 지정해야하고, 유일한 값이어야 합니다-hidden : true값을 줘서 컬럼을 숨길 수 있습니다. default값은 false입니다.이밖에 colModel에서는 다른기능들이 있습니다.이중에 formatter라는 기능이 있는데, 데이터를 뿌릴 떄 데이터를 변환하여 보여줄 수 있습니다.formatter에 대해 설명하겠습니다. 12345678910111213141516171819202122232425262728293031323334//formatter 예제formatter : function(cellValue,rowObject,options) &#123; //cellValue는 현재 셀의 값을 그대로 가져옵니다. //rowObject는 현재 셀이 포함되어있는 row를 가져옵니다. //options는 해당 데이터를 date포맷이나 다른 포맷으로 변경할 수 있습니다.&#125;colModel : [ &#123; name : 'python', index : 'python', width : 100, align : 'left', formatter : function(cellValue,rowObject,options) &#123; //원래 값은 \"python1\" 일때 return cellValue.replace(\"1\",\"\"); //화면에 보여지는 값은 python &#125; &#125;, &#123; name : 'java', index : 'java', width : 100, align : 'center' , formatter : function(cellValue,rowObject,options) &#123; //원래 값은 \"java1\" 일때 return rowObject.java.replace(\"1\",\"\"); //화면에 보여지는 값은 java &#125; &#125; ] multiselect멀티셀렉트를 사용할지 결정합니다. true로 지정 시, 컬럼의 맨앞에 체크박스가 생기며 여러 로우를 선택할 수 있습니다. captionCaption 영역에 제목을 표시합니다. height,width그리드의 가로,세로 길이를 지정할 수 있습니다. 픽셀단위이며, 퍼센티지로는 지정할 수 없습니다.","categories":[],"tags":[]},{"title":"창 resize 방법","slug":"testpost","date":"2017-01-25T09:04:03.000Z","updated":"2017-01-26T02:16:47.126Z","comments":true,"path":"2017/01/25/testpost/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/01/25/testpost/","excerpt":"","text":"동적인 css로 코딩을 하지 않았을 경우 처음 창크기에 맞게 css가 조절된 후 css가 변경되지 않을 때가 있다.이때는 jQuery를 이용해서 쉽게 resize를 시킬 수 있다. 123$(window).resize(function()&#123; //제어해야 할 코드&#125;).resize();","categories":[{"name":"javascript","slug":"javascript","permalink":"https://showbang.github.io/typistShow/categories/javascript/"}],"tags":[]},{"title":"POI를 이용하여 엑셀파일 생성하기","slug":"생성","date":"2017-01-25T08:04:11.000Z","updated":"2017-01-25T08:47:35.737Z","comments":true,"path":"2017/01/25/생성/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/01/25/생성/","excerpt":"","text":"POI 이용 엑셀 파일 생성데이터를 넘겨받아 엑셀파일로 만드는 방법에 관해 포스팅을 해보겠습니다. 먼저 POI를 이용하기 위하여 POI라이브러리가 필요합니다. POI jar파일은 http://poi.apache.org/download.html 에서 다운받은 후 라이브러리에 추가해주시면 됩니다. POI의 엑셀생성방식은 엑셀 97~03버전으로 생성되는 HSSF,엑셀 2007이상의 XSSF 그리고 가장 최근에 나온 SXSSF 세가지 방식이 있다. 이번에 포스팅할 방식은 보편화되어있는 엑셀2007이상의 XSSF 방식이다. 엑셀에 데이터를 세팅하는 방법은 각자의 방법이 있기 때문에 이번 포스팅은 나의 방식대로 포스팅 하겠다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/*** @param filePath=엑셀파일을 생성시킬 위치* @param excelName=생설할 엑셀파일의 이름* @param headerList=엑셀파일의 헤더맵* @param list=데이터를 담을 맵* @param data=엑셀파일을 생성할 데이터를 담은 리스트* 꼭 맵을통하여 세팅을 하지 않아도 상관없습니다.*/String filePath = \"파일을 생성시킬 위치\";String excelName = \"생성할 엑셀의 이름\";Map&lt;String,String&gt; headerList = new HashMap&lt;String,String&gt;();Map&lt;String,String&gt; list = new HashMap&lt;String,String&gt;();List&lt;dataType&gt; data = \"생성할 리스트를 담습니다.\";//headerList를 세팅할 만큼 세팅합니다.headerList.put(\"0\", \"이름\");headerList.put(\"1\", \"이름\");....//XSSFWorkbook 세팅XSSFWorbook workbook = new XSSFWorkbook();XSSFSheet sheet = workbook.createSheet(\"sheet의 이름\");XSSFRow row = null;XSSFCell cell = null;for(int i=0; i&lt;=data.size(); i++) &#123; //data의 크기만큼 로우를 생성합니다. row=sheet.createRow((short)i); for(int k=0; k&lt;headerList.size(); k++) &#123; //headerList의 크기만큼 i번째 row에 cell을 생성합니다. cell=row.createCell(k); //맨윗줄에 headerList를 세팅합니다. if(i==0) &#123; //CellStyle은 필요에따라서 세팅합니다. CellStyle style = workbook.createCellStyle(); style.setFillForegroundColor(\"셀color 세팅\"); style.setFillPattern(\"셀의 패턴을 세팅\"); style.setAlignment(\"셀데이터의 정렬조건 세팅\"); cell.setCellStyle(style); sheet.setColumnWidth(index,\"셀의 너비\"); //headerList의 데이터를 세팅 cell.setCellValue(headerList.get(Integer.toString(k))); &#125; //엑셀파일에 넣을 데이터를 세팅합니다. else &#123; //i-1을하는이유는 headerList가 i번쨰 row이기 때문. &lt;dataType&gt; excelData = data.get(i-1); //리스트의 크기만큼 세팅합니다. list.put(\"0\",\"넣을데이터\"); list.put(\"1\",\"넣을데이터\"); . . . cell.setCellValue(list.get(Integer.toString(k))); &#125; &#125;&#125;//엑셀파일 세팅 후 파일 생성try &#123; File file = new File(filePath); //file을 생성할 폴더가 없으면 생성합니다. file.mkdirs(); FileOutputStream fileOutputStream = new FileOutputStream(file+File.separator+excelName); //생성한 엑셀파일을 outputStream 해줍니다. workbook.write(fileOutputStream); fileOutputStream.close();&#125; catch(Exception e) &#123; e.printStackTrace();&#125; 이렇게 POI XSSF를 통하여 엑셀파일을 생성할 수 있다.왠만한 데이터는 처리 가능하지만 XSSF가 처리가능한 크기를 넘어가면OutOfMemory에러가 나기 때문에 이걸 보완한 SXSFF 를 사용할 수 도 있다.","categories":[{"name":"java","slug":"java","permalink":"https://showbang.github.io/typistShow/categories/java/"}],"tags":[]},{"title":"자바압축파일생성","slug":"자바압축파일생성","date":"2017-01-25T06:15:35.000Z","updated":"2017-01-25T07:05:04.622Z","comments":true,"path":"2017/01/25/자바압축파일생성/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/01/25/자바압축파일생성/","excerpt":"","text":"자바 압축파일 생성 방법이번에는 자바코딩으로 압축파일을 생성하는 방법을 포스팅 해보겠습니다.서버에서 파일을 다운또는 생성하여 압축파일을 생성하는 방법입니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** @param inputFolder = 압축할 폴더의 위치* @param filePath = 압축파일을 생성시킬 위치* @param zipName = 압축파일의 이름* 이렇게 인자값으로 받지 않고 메소드안에서 설정해도 무방합니다.*/public static void zip(String inputFolder, String filePath, String zipName) throws Exception &#123; //압축파일을 저장할 파일을 선언한다. FileOutputStream fileOutputStream = null; File file = new File(filePath+File.separator+\"zipName\"); fileOutputStream = new FileOutputStream(file); //ZipOutputStream 선언 ZipOutputStream zipOutputStream = new ZipOutputStream(fileOutputStream); //압축할 대상이 있는 폴더를 파일로 선언한다. File inputFile = new File(inputFolder); //압축을 할 대상이 file이면 zipFile 메소드를, //폴더이면 zipFolder 메소드를 호출한다. if(inputFile.isFile()) &#123; zipFile(inputFile) &#125; else if(inputFile.isDirectory()) &#123; zipFolder(zipOutputStream,inputFile,\"\"); &#125; zipOutputStream.close(); fileOutputStream.close();&#125;public static void zipFolder(ZipOutputStream zipOutputStream, File inputFile, String parentName) throws Exception &#123; String myName = parentName+inputFolder.getName()+File.separator; //ZipEntry를 생성 후 zip 메소드에서 인자값으로 받은 파일의 구성 정보를 생성한다. ZipEntry folderZipEntry = new ZipEntry(myName); zipOutputStream.putNextEntry(folderZipEntry); //zip 메소드에서 인자값으로 전달받은 파일의 구성파일들을 list형식으로 저장한다. File[] contents = inputFile.listFiles(); //inputFolder의 구성파일이 파일이면 zipFile 메소드를 호출하고, //폴더일 경우 현재 zipFolder 메소드를 재귀호출 for(File file : contents) &#123; if(file.isFile()) &#123; zipFile(file,myName,zipOutputStream); &#125; else if(file.isDirectory()) &#123; zipFolder(zipOutputStream,file,myName); &#125; zipOutputStream.closeEntry(); &#125;&#125;public static void zipFile(File inputFile, String parentName, ZipOutputStream zipOutputStream) throws Exception &#123; //ZipEntry생성 후 zip 메소드에서 인자값으로 전달받은 파일의 구성 정보를 생성한다. ZipEntry zipEntry = new ZipEntry(parentName+inputFile.getName()); zipOutputStream.putNextEntry(zipEntry); FileInputStream fileInputStream = new FileInputStream(inputFile); byte[] buf = new byte[4096]; int byteRead; //압축대상 파일을 설정된 사이즈만큼 읽어들인다. //buf의 size는 원하는대로 설정가능하다. while((byteRead = fileInputStream.read(buf))&gt;0) &#123; zipOutputStream.write(buf,0,bytesRead); &#125; zipOutputStream.closeEntry(); fileInputStream.close();&#125; 이렇게 Folder에서 접근하여 File만 찾아 압축하는 형식으로 압축을 한다.이렇게 자바에서 압축을 할때 주의할점은 인코딩 문제로 압축파일이름이 한글이 포함되어있으면 불가능하다.숫자,영문으로만 파일이름들을 설정한다.","categories":[{"name":"java","slug":"java","permalink":"https://showbang.github.io/typistShow/categories/java/"}],"tags":[]},{"title":"자료형비교","slug":"자료형비교","date":"2017-01-17T06:21:35.000Z","updated":"2017-01-25T09:05:43.622Z","comments":true,"path":"2017/01/17/자료형비교/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/01/17/자료형비교/","excerpt":"","text":"자바스크립트 == 연산자와 === 연산자의 차이점자바스크립트 소스코드를 찾다보면 비교연산자중 ==와 ===를 볼 수 있다.이 둘의 차이점은== =&gt; 값을 비교한다.=== =&gt; 값과 자료형을 비교한다. 예를 들면 123456789101112131415161718var a = 1;var b = \"1\";// ==연산자일 경우 값이 같으므로 true 반환if(a==b) &#123; alert(\"true\");&#125; else &#123; alert(\"false\");&#125;// ===연산자의 경우 값은 같지만, 자료형이 다르므로 false 반환// int값과 String값의 자료형 비교는 false.if(a===b) &#123; alert(\"true\");&#125; else &#123; alert(\"false\");&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://showbang.github.io/typistShow/categories/javascript/"}],"tags":[]},{"title":"Servlet이란","slug":"폴더테스트","date":"2017-01-11T00:37:17.000Z","updated":"2017-01-25T09:05:34.434Z","comments":true,"path":"2017/01/11/폴더테스트/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/01/11/폴더테스트/","excerpt":"","text":"Servlet이란??서블릿은 Server+Applet으로 “Client의 요청을 처리하고 그 결과를 다시 Client에게 전송하는 Servlet Class의 구현 규칙을 지킨 자바 프로그램”이다.자바프로그램이라고 정의했다면 당연히 JDK가 필요하며, 자바 API를 동작시키는 JVM이 필요하다. Servlet은 Web Application 확장이 용이하고 플랫폼에 독립적이다. Servlet Container란??Container라는 용어처럼 말그대로 Servlet이 제공하는 기능을 실행시켜주며 관리해주는 것이다. Servlet Container는 Servlet의 LifeCycle을 관리하고요청에 따른 Thread를 생성해준다. 또한 Client의 요청을 받아주고 응답을 보낼 수 있게 웹서버와 소켓통신을 한다.Servlet Container의 기능을 자세히 보면-Servlet과 Web Server가 통신하기 용이하게 해준다. 우리가 통신을 한다고 생각했을 때 Socket을 만들고, 특정 Port를 수집하고, Request가 들어오면 Stream을 생성해서요청을 받는것이 순서이다. 이과정을 Servlet Container가 담당한다. Servlet Container는 이과정을 API로 제공하고 있기 때문에 손쉽게 사용되고 있다.-Servlet Container가 기동되는 순간 Servlet Class를 로딩하여 인스턴스화 시키고, 초기화 메소드를 호출한 후 요청이 들어오면 알맞은 Servlet 메소드를 호출한다.Servlet의 Life Cycle이 끝나는 순간 Garbage Collection을 진행한다.-Servet Container는 해당 Servlet의 요청이 들어오면 Thread를 생성하여 작업을 수행한다. 동시에 여러 요청이 들어온다면 멀티쓰레딩으로 동시다발적은 작업을 진행한다.-Servlet Container는 보안 관련된 기능을 지원하여, Servlet 코드 안에 보안 관련 메소드를 구현하지 않아도 된다. Servlet은 자바 API를 모두 사용할 수 있고, O/S나 H/W에 영향을 받지 않아 유지보수가 수월하다. 그리고 컨텐츠와 비즈니스 로직을 분리하여 개발할 수 있고, 이렇게 분리가 되면 백엔드,미들웨어,프런트엔드 개발자들 끼리의 분업이 원활하게 이루어 질 수 있다. 이런 기능을 하기 위하여 Servlet은 LifeCycle이라는 것이 존재한다. Servlet LifeCycle void init(ServletConfig config) - Servlet이 처음 적재될때 호출되는 초기화 함수이다. 이미 init method가 한번 호출되어 적재되어 있을 경우는 init method를 호출하지 않고 service()를 호출하게 된다. 즉 init()은 처음 Servlet 적재시만 사용된다. void service(HttpServletRequest request, HttpServletResponse response) - client의 요청이 들어올 때 마다 호출되는 함수로써, 요청에 방식에 따라 그에 맞는 doGet(), doPost()를 호출한다. get,post 방식 둘다 받을 수 있는 service()메소드도 있다. void destory() - Servlet의 메모리에서 해제할 때 호출되는 함수이다. 만약 destroy() 호출을 한다면 다시 Servlet에 적재할 경우 init()을 호출해야 한다. 이것이 Servlet LifeCycle이다. 하지만 거의 대부분은 아마 service()에서 이루어 질 것이다. service에서 doGet(),doPost() 메소드를 overriding하여 요청을 처리한다. 이 곳에서 HTML 코드를 코딩하여 결과를 생성할 수 있지만, Servlet을 사용해 봤다면 java code상으로 html을 생성한다는게 정말 귀찮다. 이것을 보완한 기능인 JSP를 많이 사용하고 있으며 JSP로 forwarding하여 처리하는 것이 코드상으로도 깔끔하다 유지보수도 용이하다.","categories":[{"name":"java","slug":"java","permalink":"https://showbang.github.io/typistShow/categories/java/"}],"tags":[]},{"title":"static, final, abstract","slug":"staticFinal","date":"2017-01-10T07:37:03.000Z","updated":"2017-01-25T09:10:20.775Z","comments":true,"path":"2017/01/10/staticFinal/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/01/10/staticFinal/","excerpt":"","text":"Related Postsstatic -field와 method 앞에 붙는다. -method 앞에 붙을경우는 field를 변경하지 못한다. -static은 class를 같이 가지고 메모리에 적재되기 때문에 생성자 없이 ClassName으로 접근 가능하다. final -마지막 상태값을 가져야 할때 쓰는 keword. -변수에 final이 붙으면 변수를 상수화 시킨다. -final이 Class에 붙으면 그 Class는 더이상 확장시키지 않는다. -final이 method에 붙으면 그 method는 더이상 overriding 하지 않는다. -final이 field에 붙으면 그 값은 더이상 상태값을 변경시키지 않는다. abstract -오버라이딩하여 하위클래스에서 메소드를 호출하게 되면 상위클래스에 있는 메소드는 사용되지 않기 때문에 상위클래스의 메소드는 abstract를 이용하여 추상화시킨다.","categories":[{"name":"java","slug":"java","permalink":"https://showbang.github.io/typistShow/categories/java/"}],"tags":[]},{"title":"contains, substring, indexOf","slug":"page","date":"2017-01-10T05:00:54.000Z","updated":"2017-01-25T06:13:10.760Z","comments":true,"path":"2017/01/10/page/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/01/10/page/","excerpt":"","text":"contains - 문자나 문자열을 포함하는지 확인 후 true,false 반환substring - 문자열의 인덱스값을 받은 후, 인덱스값에 알맞는 문자 또는 문자열을 반환indexOf - 문자나 문자열을 받아 그에 맞는 인덱스 값을 반환 사용법을 예로 들면 contains123String movieTitle=\"나는 네가 지난 여름에 한 일을 알고 있다.\";System.out.println(\"contains의 반환값 =&gt;\"+movieTitle.contains(\"여름\"));System.out.println(\"contains의 반환값 =&gt;\"+movieTitle.contains(\"겨울\")); 이렇게 contains의 인자값이 포함되어 있으면 true 없으면 false를 반환한다. substring만약 인자값을 하나의 인덱스만 준다면 그 인덱스부터 문자열을 반환한다.12String movieTitle=\"나는 네가 지난 여름에 한 일을 알고 있다.\";System.out.println(\"6번째 인덱스의 문자=&gt;\"+movieTitle.substring(6)); 인자값을 두개를 준다면 첫번째 인자값은 시작되는 인덱스를 두번째 인덱스는 끝나는 인덱스를 의미한다. 주의할 점은 끝나는 인덱스를 포함하지 않고 그전 인덱스까지만 출력한다.만약 밑의 코딩처럼 입력한다면 출력문은 아래와 같다. 네가에서 끝난게 아니라 네가다음의 공백까지 출력된다.12String movieTitle = \"나는 네가 지난 여름에 한 일을 알고 있다.\"System.out.println(\"0번째 인덱스부터 6번째 인덱스까지의 문자열=&gt;\"+movieTitle.substring(0,6)); indexOf문자를 줬을때는 그 문자의 인덱스를 문자열을 줬을때는 문자열이 시작하는 부분의 인덱스를 반환한다.12String movieTitle = \"나는 네가 지난 여름에 한 일을 알고 있다.\"System.out.println(\"지난이라는 문자열을 포함한 인덱스의 시작값=&gt;\"+movieTitle.indexOf(\"지난\")); 12","categories":[{"name":"java","slug":"java","permalink":"https://showbang.github.io/typistShow/categories/java/"}],"tags":[]}]}