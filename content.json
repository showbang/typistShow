{"meta":{"title":"Show's blog","subtitle":"Show's blog using hexo","description":"my first hexo blog","author":"keunhan Lee","url":"https://showbang.github.io/typistShow"},"pages":[],"posts":[{"title":"POI를 이용하여 엑셀파일 생성하기","slug":"생성","date":"2017-01-25T08:04:11.000Z","updated":"2017-01-25T08:47:35.737Z","comments":true,"path":"2017/01/25/생성/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/01/25/생성/","excerpt":"","text":"POI 이용 엑셀 파일 생성데이터를 넘겨받아 엑셀파일로 만드는 방법에 관해 포스팅을 해보겠습니다. 먼저 POI를 이용하기 위하여 POI라이브러리가 필요합니다. POI jar파일은 http://poi.apache.org/download.html 에서 다운받은 후 라이브러리에 추가해주시면 됩니다. POI의 엑셀생성방식은 엑셀 97~03버전으로 생성되는 HSSF,엑셀 2007이상의 XSSF 그리고 가장 최근에 나온 SXSSF 세가지 방식이 있다. 이번에 포스팅할 방식은 보편화되어있는 엑셀2007이상의 XSSF 방식이다. 엑셀에 데이터를 세팅하는 방법은 각자의 방법이 있기 때문에 이번 포스팅은 나의 방식대로 포스팅 하겠다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/*** @param filePath=엑셀파일을 생성시킬 위치* @param excelName=생설할 엑셀파일의 이름* @param headerList=엑셀파일의 헤더맵* @param list=데이터를 담을 맵* @param data=엑셀파일을 생성할 데이터를 담은 리스트* 꼭 맵을통하여 세팅을 하지 않아도 상관없습니다.*/String filePath = \"파일을 생성시킬 위치\";String excelName = \"생성할 엑셀의 이름\";Map&lt;String,String&gt; headerList = new HashMap&lt;String,String&gt;();Map&lt;String,String&gt; list = new HashMap&lt;String,String&gt;();List&lt;dataType&gt; data = \"생성할 리스트를 담습니다.\";//headerList를 세팅할 만큼 세팅합니다.headerList.put(\"0\", \"이름\");headerList.put(\"1\", \"이름\");....//XSSFWorkbook 세팅XSSFWorbook workbook = new XSSFWorkbook();XSSFSheet sheet = workbook.createSheet(\"sheet의 이름\");XSSFRow row = null;XSSFCell cell = null;for(int i=0; i&lt;=data.size(); i++) &#123; //data의 크기만큼 로우를 생성합니다. row=sheet.createRow((short)i); for(int k=0; k&lt;headerList.size(); k++) &#123; //headerList의 크기만큼 i번째 row에 cell을 생성합니다. cell=row.createCell(k); //맨윗줄에 headerList를 세팅합니다. if(i==0) &#123; //CellStyle은 필요에따라서 세팅합니다. CellStyle style = workbook.createCellStyle(); style.setFillForegroundColor(\"셀color 세팅\"); style.setFillPattern(\"셀의 패턴을 세팅\"); style.setAlignment(\"셀데이터의 정렬조건 세팅\"); cell.setCellStyle(style); sheet.setColumnWidth(index,\"셀의 너비\"); //headerList의 데이터를 세팅 cell.setCellValue(headerList.get(Integer.toString(k))); &#125; //엑셀파일에 넣을 데이터를 세팅합니다. else &#123; //i-1을하는이유는 headerList가 i번쨰 row이기 때문. &lt;dataType&gt; excelData = data.get(i-1); //리스트의 크기만큼 세팅합니다. list.put(\"0\",\"넣을데이터\"); list.put(\"1\",\"넣을데이터\"); . . . cell.setCellValue(list.get(Integer.toString(k))); &#125; &#125;&#125;//엑셀파일 세팅 후 파일 생성try &#123; File file = new File(filePath); //file을 생성할 폴더가 없으면 생성합니다. file.mkdirs(); FileOutputStream fileOutputStream = new FileOutputStream(file+File.separator+excelName); //생성한 엑셀파일을 outputStream 해줍니다. workbook.write(fileOutputStream); fileOutputStream.close();&#125; catch(Exception e) &#123; e.printStackTrace();&#125; 이렇게 POI XSSF를 통하여 엑셀파일을 생성할 수 있다.왠만한 데이터는 처리 가능하지만 XSSF가 처리가능한 크기를 넘어가면OutOfMemory에러가 나기 때문에 이걸 보완한 SXSFF 를 사용할 수 도 있다.","categories":[{"name":"java","slug":"java","permalink":"https://showbang.github.io/typistShow/categories/java/"}],"tags":[]},{"title":"자바압축파일생성","slug":"자바압축파일생성","date":"2017-01-25T06:15:35.000Z","updated":"2017-01-25T07:05:04.622Z","comments":true,"path":"2017/01/25/자바압축파일생성/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/01/25/자바압축파일생성/","excerpt":"","text":"자바 압축파일 생성 방법이번에는 자바코딩으로 압축파일을 생성하는 방법을 포스팅 해보겠습니다.서버에서 파일을 다운또는 생성하여 압축파일을 생성하는 방법입니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** @param inputFolder = 압축할 폴더의 위치* @param filePath = 압축파일을 생성시킬 위치* @param zipName = 압축파일의 이름* 이렇게 인자값으로 받지 않고 메소드안에서 설정해도 무방합니다.*/public static void zip(String inputFolder, String filePath, String zipName) throws Exception &#123; //압축파일을 저장할 파일을 선언한다. FileOutputStream fileOutputStream = null; File file = new File(filePath+File.separator+\"zipName\"); fileOutputStream = new FileOutputStream(file); //ZipOutputStream 선언 ZipOutputStream zipOutputStream = new ZipOutputStream(fileOutputStream); //압축할 대상이 있는 폴더를 파일로 선언한다. File inputFile = new File(inputFolder); //압축을 할 대상이 file이면 zipFile 메소드를, //폴더이면 zipFolder 메소드를 호출한다. if(inputFile.isFile()) &#123; zipFile(inputFile) &#125; else if(inputFile.isDirectory()) &#123; zipFolder(zipOutputStream,inputFile,\"\"); &#125; zipOutputStream.close(); fileOutputStream.close();&#125;public static void zipFolder(ZipOutputStream zipOutputStream, File inputFile, String parentName) throws Exception &#123; String myName = parentName+inputFolder.getName()+File.separator; //ZipEntry를 생성 후 zip 메소드에서 인자값으로 받은 파일의 구성 정보를 생성한다. ZipEntry folderZipEntry = new ZipEntry(myName); zipOutputStream.putNextEntry(folderZipEntry); //zip 메소드에서 인자값으로 전달받은 파일의 구성파일들을 list형식으로 저장한다. File[] contents = inputFile.listFiles(); //inputFolder의 구성파일이 파일이면 zipFile 메소드를 호출하고, //폴더일 경우 현재 zipFolder 메소드를 재귀호출 for(File file : contents) &#123; if(file.isFile()) &#123; zipFile(file,myName,zipOutputStream); &#125; else if(file.isDirectory()) &#123; zipFolder(zipOutputStream,file,myName); &#125; zipOutputStream.closeEntry(); &#125;&#125;public static void zipFile(File inputFile, String parentName, ZipOutputStream zipOutputStream) throws Exception &#123; //ZipEntry생성 후 zip 메소드에서 인자값으로 전달받은 파일의 구성 정보를 생성한다. ZipEntry zipEntry = new ZipEntry(parentName+inputFile.getName()); zipOutputStream.putNextEntry(zipEntry); FileInputStream fileInputStream = new FileInputStream(inputFile); byte[] buf = new byte[4096]; int byteRead; //압축대상 파일을 설정된 사이즈만큼 읽어들인다. //buf의 size는 원하는대로 설정가능하다. while((byteRead = fileInputStream.read(buf))&gt;0) &#123; zipOutputStream.write(buf,0,bytesRead); &#125; zipOutputStream.closeEntry(); fileInputStream.close();&#125; 이렇게 Folder에서 접근하여 File만 찾아 압축하는 형식으로 압축을 한다.이렇게 자바에서 압축을 할때 주의할점은 인코딩 문제로 압축파일이름이 한글이 포함되어있으면 불가능하다.숫자,영문으로만 파일이름들을 설정한다.","categories":[{"name":"java","slug":"java","permalink":"https://showbang.github.io/typistShow/categories/java/"}],"tags":[]},{"title":"자료형비교","slug":"자료형비교","date":"2017-01-17T06:21:35.000Z","updated":"2017-01-25T06:13:07.018Z","comments":true,"path":"2017/01/17/자료형비교/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/01/17/자료형비교/","excerpt":"","text":"자바스크립트 == 연산자와 === 연산자의 차이점자바스크립트 소스코드를 찾다보면 비교연산자중 ==와 ===를 볼 수 있다.이 둘의 차이점은== =&gt; 값을 비교한다.=== =&gt; 값과 자료형을 비교한다. 예를 들면 123456789101112131415161718var a = 1;var b = \"1\";// ==연산자일 경우 값이 같으므로 true 반환if(a==b) &#123; alert(\"true\");&#125; else &#123; alert(\"false\");&#125;// ===연산자의 경우 값은 같지만, 자료형이 다르므로 false 반환// int값과 String값의 자료형 비교는 false.if(a===b) &#123; alert(\"true\");&#125; else &#123; alert(\"false\");&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://showbang.github.io/typistShow/categories/javascript/"}],"tags":[]},{"title":"Servlet이란","slug":"폴더테스트","date":"2017-01-11T00:37:17.000Z","updated":"2017-01-25T07:43:50.621Z","comments":true,"path":"2017/01/11/폴더테스트/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/01/11/폴더테스트/","excerpt":"","text":"Servlet이란??서블릿은 Server+Applet으로 “Client의 요청을 처리하고 그 결과를 다시 Client에게 전송하는 Servlet Class의 구현 규칙을 지킨 자바 프로그램”이다.자바프로그램이라고 정의했다면 당연히 JDK가 필요하며, 자바 API를 동작시키는 JVM이 필요하다. Servlet은 Web Application 확장이 용이하고 플랫폼에 독립적이다. Servlet Container란??Container라는 용어처럼 말그대로 Servlet이 제공하는 기능을 실행시켜주며 관리해주는 것이다. Servlet Container는 Servlet의 LifeCycle을 관리하고요청에 따른 Thread를 생성해준다. 또한 Client의 요청을 받아주고 응답을 보낼 수 있게 웹서버와 소켓통신을 한다.Servlet Container의 기능을 자세히 보면-Servlet과 Web Server가 통신하기 용이하게 해준다. 우리가 통신을 한다고 생각했을 때 Socket을 만들고, 특정 Port를 수집하고, Request가 들어오면 Stream을 생성해서요청을 받는것이 순서이다. 이과정을 Servlet Container가 담당한다. Servlet Container는 이과정을 API로 제공하고 있기 때문에 손쉽게 사용되고 있다.-Servlet Container가 기동되는 순간 Servlet Class를 로딩하여 인스턴스화 시키고, 초기화 메소드를 호출한 후 요청이 들어오면 알맞은 Servlet 메소드를 호출한다.Servlet의 Life Cycle이 끝나는 순간 Garbage Collection을 진행한다.-Servet Container는 해당 Servlet의 요청이 들어오면 Thread를 생성하여 작업을 수행한다. 동시에 여러 요청이 들어온다면 멀티쓰레딩으로 동시다발적은 작업을 진행한다.-Servlet Container는 보안 관련된 기능을 지원하여, Servlet 코드 안에 보안 관련 메소드를 구현하지 않아도 된다. Servlet은 자바 API를 모두 사용할 수 있고, O/S나 H/W에 영향을 받지 않아 유지보수가 수월하다. 그리고 컨텐츠와 비즈니스 로직을 분리하여 개발할 수 있고, 이렇게 분리가 되면 백엔드,미들웨어,프런트엔드 개발자들 끼리의 분업이 원활하게 이루어 질 수 있다. 이런 기능을 하기 위하여 Servlet은 LifeCycle이라는 것이 존재한다. Servlet LifeCycle void init(ServletConfig config) - Servlet이 처음 적재될때 호출되는 초기화 함수이다. 이미 init method가 한번 호출되어 적재되어 있을 경우는 init method를 호출하지 않고 service()를 호출하게 된다. 즉 init()은 처음 Servlet 적재시만 사용된다. void service(HttpServletRequest request, HttpServletResponse response) - client의 요청이 들어올 때 마다 호출되는 함수로써, 요청에 방식에 따라 그에 맞는 doGet(), doPost()를 호출한다. get,post 방식 둘다 받을 수 있는 service()메소드도 있다. void destory() - Servlet의 메모리에서 해제할 때 호출되는 함수이다. 만약 destroy() 호출을 한다면 다시 Servlet에 적재할 경우 init()을 호출해야 한다. 이것이 Servlet LifeCycle이다. 하지만 거의 대부분은 아마 service()에서 이루어 질 것이다. service에서 doGet(),doPost() 메소드를 overriding하여 요청을 처리한다. 이 곳에서 HTML 코드를 코딩하여 결과를 생성할 수 있지만, Servlet을 사용해 봤다면 java code상으로 html을 생성한다는게 정말 귀찮다. 이것을 보완한 기능인 JSP를 많이 사용하고 있으며 JSP로 forwarding하여 처리하는 것이 코드상으로도 깔끔하다 유지보수도 용이하다.","categories":[{"name":"java","slug":"java","permalink":"https://showbang.github.io/typistShow/categories/java/"}],"tags":[]},{"title":"static, final, abstract","slug":"staticFinal","date":"2017-01-10T07:37:03.000Z","updated":"2017-01-25T06:12:57.172Z","comments":true,"path":"2017/01/10/staticFinal/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/01/10/staticFinal/","excerpt":"","text":"Related Postsstatic -field와 method 앞에 붙는다. -method 앞에 붙을경우는 field를 변경하지 못한다. -static은 class를 같이 가지고 메모리에 적재되기 때문에 생성자 없이 ClassName으로 접근 가능하다. final -마지막 상태값을 가져야 할때 쓰는 keword. -변수에 final이 붙으면 변수를 상수화 시킨다. -final이 Class에 붙으면 그 Class는 더이상 확장시키지 않는다. -final이 method에 붙으면 그 method는 더이상 overriding 하지 않는다. -final이 field에 붙으면 그 값은 더이상 상태값을 변경시키지 않는다. abstract -오버라이딩하여 하위클래스에서 메소드를 호출하게 되면 상위클래스에 있는 메소드는 사용되지 않기 때문에 상위클래스의 메소드는 abstract를 이용하여 추상화시킨다.","categories":[{"name":"java","slug":"java","permalink":"https://showbang.github.io/typistShow/categories/java/"}],"tags":[]},{"title":"contains, substring, indexOf","slug":"page","date":"2017-01-10T05:00:54.000Z","updated":"2017-01-25T06:13:10.760Z","comments":true,"path":"2017/01/10/page/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/01/10/page/","excerpt":"","text":"contains - 문자나 문자열을 포함하는지 확인 후 true,false 반환substring - 문자열의 인덱스값을 받은 후, 인덱스값에 알맞는 문자 또는 문자열을 반환indexOf - 문자나 문자열을 받아 그에 맞는 인덱스 값을 반환 사용법을 예로 들면 contains123String movieTitle=\"나는 네가 지난 여름에 한 일을 알고 있다.\";System.out.println(\"contains의 반환값 =&gt;\"+movieTitle.contains(\"여름\"));System.out.println(\"contains의 반환값 =&gt;\"+movieTitle.contains(\"겨울\")); 이렇게 contains의 인자값이 포함되어 있으면 true 없으면 false를 반환한다. substring만약 인자값을 하나의 인덱스만 준다면 그 인덱스부터 문자열을 반환한다.12String movieTitle=\"나는 네가 지난 여름에 한 일을 알고 있다.\";System.out.println(\"6번째 인덱스의 문자=&gt;\"+movieTitle.substring(6)); 인자값을 두개를 준다면 첫번째 인자값은 시작되는 인덱스를 두번째 인덱스는 끝나는 인덱스를 의미한다. 주의할 점은 끝나는 인덱스를 포함하지 않고 그전 인덱스까지만 출력한다.만약 밑의 코딩처럼 입력한다면 출력문은 아래와 같다. 네가에서 끝난게 아니라 네가다음의 공백까지 출력된다.12String movieTitle = \"나는 네가 지난 여름에 한 일을 알고 있다.\"System.out.println(\"0번째 인덱스부터 6번째 인덱스까지의 문자열=&gt;\"+movieTitle.substring(0,6)); indexOf문자를 줬을때는 그 문자의 인덱스를 문자열을 줬을때는 문자열이 시작하는 부분의 인덱스를 반환한다.12String movieTitle = \"나는 네가 지난 여름에 한 일을 알고 있다.\"System.out.println(\"지난이라는 문자열을 포함한 인덱스의 시작값=&gt;\"+movieTitle.indexOf(\"지난\")); 12","categories":[{"name":"java","slug":"java","permalink":"https://showbang.github.io/typistShow/categories/java/"}],"tags":[]},{"title":"창크기 조절 시 창 크기에 맞게 CSS 조절하는 방법.","slug":"testpost","date":"2017-01-10T04:20:28.000Z","updated":"2017-01-25T06:13:15.591Z","comments":true,"path":"2017/01/10/testpost/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/01/10/testpost/","excerpt":"","text":"동적인 css로 코딩을 하지 않았을 경우 처음 창크기에 맞게 css가 조절된 후 css가 변경되지 않을 때가 있다.이때는 jQuery를 이용해서 쉽게 resize를 시킬 수 있다. 123$(window).resize(function()&#123; //제어해야 할 코드&#125;).resize();","categories":[{"name":"javascript","slug":"javascript","permalink":"https://showbang.github.io/typistShow/categories/javascript/"}],"tags":[]}]}