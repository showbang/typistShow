{"meta":{"title":"Show's blog","subtitle":"Show's blog using hexo","description":"my first hexo blog","author":"keunhan Lee","url":"https://showbang.github.io/typistShow"},"pages":[],"posts":[{"title":"서블릿테스트","slug":"폴더테스트","date":"2017-01-11T00:37:17.000Z","updated":"2017-01-11T05:41:28.572Z","comments":true,"path":"2017/01/11/폴더테스트/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/01/11/폴더테스트/","excerpt":"","text":"Servlet이란??서블릿은 Server+Applet으로 “Client의 요청을 처리하고 그 결과를 다시 Client에게 전송하는 Servlet Class의 구현 규칙을 지킨 자바 프로그램”이다.자바프로그램이라고 정의했다면 당연히 JDK가 필요하며, 자바 API를 동작시키는 JVM이 필요하다. Servlet은 Web Application 확장이 용이하고 플랫폼에 독립적이다. Servlet Container란??Container라는 용어처럼 말그대로 Servlet이 제공하는 기능을 실행시켜주며 관리해주는 것이다. Servlet Container는 Servlet의 LifeCycle을 관리하고요청에 따른 Thread를 생성해준다. 또한 Client의 요청을 받아주고 응답을 보낼 수 있게 웹서버와 소켓통신을 한다.Servlet Container의 기능을 자세히 보면-Servlet과 Web Server가 통신하기 용이하게 해준다. 우리가 통신을 한다고 생각했을 때 Socket을 만들고, 특정 Port를 수집하고, Request가 들어오면 Stream을 생성해서요청을 받는것이 순서이다. 이과정을 Servlet Container가 담당한다. Servlet Container는 이과정을 API로 제공하고 있기 때문에 손쉽게 사용되고 있다.-Servlet Container가 기동되는 순간 Servlet Class를 로딩하여 인스턴스화 시키고, 초기화 메소드를 호출한 후 요청이 들어오면 알맞은 Servlet 메소드를 호출한다.Servlet의 Life Cycle이 끝나는 순간 Garbage Collection을 진행한다.-Servet Container는 해당 Servlet의 요청이 들어오면 Thread를 생성하여 작업을 수행한다. 동시에 여러 요청이 들어온다면 멀티쓰레딩으로 동시다발적은 작업을 진행한다.-Servlet Container는 보안 관련된 기능을 지원하여, Servlet 코드 안에 보안 관련 메소드를 구현하지 않아도 된다. Servlet은 자바 API를 모두 사용할 수 있고, O/S나 H/W에 영향을 받지 않아 유지보수가 수월하다. 그리고 컨텐츠와 비즈니스 로직을 분리하여 개발할 수 있고, 이렇게 분리가 되면 백엔드,미들웨어,프런트엔드 개발자들 끼리의 분업이 원활하게 이루어 질 수 있다. 이런 기능을 하기 위하여 Servlet은 LifeCycle이라는 것이 존재한다. Servlet LifeCycle void init(ServletConfig config) - Servlet이 처음 적재될때 호출되는 초기화 함수이다. 이미 init method가 한번 호출되어 적재되어 있을 경우는 init method를 호출하지 않고 service()를 호출하게 된다. 즉 init()은 처음 Servlet 적재시만 사용된다. void service(HttpServletRequest request, HttpServletResponse response) - client의 요청이 들어올 때 마다 호출되는 함수로써, 요청에 방식에 따라 그에 맞는 doGet(), doPost()를 호출한다. get,post 방식 둘다 받을 수 있는 service()메소드도 있다. void destory() - Servlet의 메모리에서 해제할 때 호출되는 함수이다. 만약 destroy() 호출을 한다면 다시 Servlet에 적재할 경우 init()을 호출해야 한다. 이것이 Servlet LifeCycle이다. 하지만 거의 대부분은 아마 service()에서 이루어 질 것이다. service에서 doGet(),doPost() 메소드를 overriding하여 요청을 처리한다. 이 곳에서 HTML 코드를 코딩하여 결과를 생성할 수 있지만, Servlet을 사용해 봤다면 java code상으로 html을 생성한다는게 정말 귀찮다. 이것을 보완한 기능인 JSP를 많이 사용하고 있으며 JSP로 forwarding하여 처리하는 것이 코드상으로도 깔끔하다 유지보수도 용이하다. 1$ hexo new posts","categories":[],"tags":[]},{"title":"static, final, abstract","slug":"staticFinal","date":"2017-01-10T07:37:03.000Z","updated":"2017-01-10T07:57:16.682Z","comments":true,"path":"2017/01/10/staticFinal/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/01/10/staticFinal/","excerpt":"","text":"Related Postsstatic -field와 method 앞에 붙는다. -method 앞에 붙을경우는 field를 변경하지 못한다. -static은 class를 같이 가지고 메모리에 적재되기 때문에 생성자 없이 ClassName으로 접근 가능하다. final -마지막 상태값을 가져야 할때 쓰는 keword. -변수에 final이 붙으면 변수를 상수화 시킨다. -final이 Class에 붙으면 그 Class는 더이상 확장시키지 않는다. -final이 method에 붙으면 그 method는 더이상 overriding 하지 않는다. -final이 field에 붙으면 그 값은 더이상 상태값을 변경시키지 않는다. abstract -오버라이딩하여 하위클래스에서 메소드를 호출하게 되면 상위클래스에 있는 메소드는 사용되지 않기 때문에 상위클래스의 메소드는 abstract를 이용하여 추상화시킨다.","categories":[],"tags":[]},{"title":"테스트.","slug":"inyoung","date":"2017-01-10T07:31:27.000Z","updated":"2017-01-12T05:35:18.640Z","comments":true,"path":"2017/01/10/inyoung/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/01/10/inyoung/","excerpt":"","text":"그치???","categories":[],"tags":[]},{"title":"contains, substring, indexOf","slug":"page","date":"2017-01-10T05:00:54.000Z","updated":"2017-01-10T07:50:32.280Z","comments":true,"path":"2017/01/10/page/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/01/10/page/","excerpt":"","text":"contains - 문자나 문자열을 포함하는지 확인 후 true,false 반환substring - 문자열의 인덱스값을 받은 후, 인덱스값에 알맞는 문자 또는 문자열을 반환indexOf - 문자나 문자열을 받아 그에 맞는 인덱스 값을 반환 사용법을 예로 들면 contains123String movieTitle=\"나는 네가 지난 여름에 한 일을 알고 있다.\";System.out.println(\"contains의 반환값 =&gt;\"+movieTitle.contains(\"여름\"));System.out.println(\"contains의 반환값 =&gt;\"+movieTitle.contains(\"겨울\")); 이렇게 contains의 인자값이 포함되어 있으면 true 없으면 false를 반환한다. substring만약 인자값을 하나의 인덱스만 준다면 그 인덱스부터 문자열을 반환한다.12String movieTitle=\"나는 네가 지난 여름에 한 일을 알고 있다.\";System.out.println(\"6번째 인덱스의 문자=&gt;\"+movieTitle.substring(6)); 인자값을 두개를 준다면 첫번째 인자값은 시작되는 인덱스를 두번째 인덱스는 끝나는 인덱스를 의미한다. 주의할 점은 끝나는 인덱스를 포함하지 않고 그전 인덱스까지만 출력한다.만약 밑의 코딩처럼 입력한다면 출력문은 아래와 같다. 네가에서 끝난게 아니라 네가다음의 공백까지 출력된다.12String movieTitle = \"나는 네가 지난 여름에 한 일을 알고 있다.\"System.out.println(\"0번째 인덱스부터 6번째 인덱스까지의 문자열=&gt;\"+movieTitle.substring(0,6)); indexOf문자를 줬을때는 그 문자의 인덱스를 문자열을 줬을때는 문자열이 시작하는 부분의 인덱스를 반환한다.12String movieTitle = \"나는 네가 지난 여름에 한 일을 알고 있다.\"System.out.println(\"지난이라는 문자열을 포함한 인덱스의 시작값=&gt;\"+movieTitle.indexOf(\"지난\"));","categories":[],"tags":[]},{"title":"창크기 조절 시 창 크기에 맞게 CSS 조절하는 방법.","slug":"testpost","date":"2017-01-10T04:20:28.000Z","updated":"2017-01-10T07:49:29.028Z","comments":true,"path":"2017/01/10/testpost/","link":"","permalink":"https://showbang.github.io/typistShow/typistShow/2017/01/10/testpost/","excerpt":"","text":"동적인 css로 코딩을 하지 않았을 경우 처음 창크기에 맞게 css가 조절된 후 css가 변경되지 않을 때가 있다.이때는 jQuery를 이용해서 쉽게 resize를 시킬 수 있다. 123$(window).resize(function()&#123; //제어해야 할 코드&#125;).resize();","categories":[],"tags":[]}]}